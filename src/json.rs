// Crate inclusion
//
// Serialization
extern crate serde;
extern crate serde_json;
// Blockchain
extern crate off_blockway;
// Used for telling time
extern crate chrono;
// Used for random numbers
extern crate rand;

// Use statements
//
// Standard library's functionality for file paths
#[allow(unused_imports)]
use std::path::Path;
// Prelude
#[allow(unused_imports)]
use std::io::prelude::*;
// Commands
#[allow(unused_imports)]
use std::process::Command;
// Standard library
#[allow(unused_imports)]
use std::*;
// Used for timestamps
#[allow(unused_imports)]
use self::chrono::Utc;
// Use off blockway functionality
#[allow(unused_imports)]
use self::off_blockway::*;
// Merkle Trees
#[allow(unused_imports)]
use self::off_blockway::merkle::Merkle;
// Hash utilities
#[allow(unused_imports)]
use self::off_blockway::hash_util::*;
// Blocks
#[allow(unused_imports)]
use self::off_blockway::block::Block;
// Transactions
#[allow(unused_imports)]
use self::off_blockway::transaction::Transaction;
// Used for serialization
#[allow(unused_imports)]
use self::serde_json::{ Error, Value };
// Used for writing to files
#[allow(unused_imports)]
use std::fs::{ OpenOptions, File };
// Strings
#[allow(unused_imports)]
use std::string::String;
// Random numbers
#[allow(unused_imports)]
use rand::distributions::{ Range, IndependentSample };

/*
 *
 * JSON:
 *     - Contains all structs and impls associated with JSON serialization of the data sent 
 *       to the client. 
 * 
 */

/*
 *
 * Passport:
 *     - Struct and impl for passport and associated functions  
 *
 */

// Passport struct
//
// Derive statement used for JSON serialization 
#[derive( Serialize, Deserialize )]
pub struct Passport
{

    // Unique ID of the mining node
    uid: String,
    // Timestamp on running the client
    timestamp: String,
    // Url of the current server
    url: String
    
}

// Impl for the passport
impl Passport
{

    // Constructor for a new passport
    #[allow(dead_code)]
    pub fn new() -> Self
    {

        // The current ip address 
        let ip = Command::new( "ipconfig" ).args( &[ "getifaddr", "en0" ] ).output()
            .expect( "Could not find IP address" );
        // The Command as a string
        let mut ip_string = String::from_utf8( ip.stdout ).unwrap();
        // The string is returned with a new line character so we remove this
        let length = ip_string.len();
        // Truncate by the length - 2 ( "\n" )
        ip_string.truncate( length - 2 );
        // The current time
        let current_time = Utc::now().to_string();
        // The url of the current user
        //
        // First make a copy of the ip string so there is no move error
        let mut ip_copy = ip_string.clone();
        // Pushes the string ":3000" to complete the url 
        ip_copy.push_str( ":3000" );
        let url_string = ip_copy.clone();
        // The unique id is generated by hashing the user's ip address
        let unique_hash = hash_util::create_leaf_hash( &ip_copy.clone() );
        // Creates a new passport and sets the fields based on the calculated value 
        let pass = Passport
        {

            uid: unique_hash, 
            timestamp: current_time,
            url: url_string

        };
        pass
        
    }

    // Serializes the passport as JSON
    #[allow(dead_code)]
    pub fn write_to( &self, file_name: &str ) -> Result< (), Error >
    {

        // Open the filepath with write specification
        #[allow(unused_must_use)]
        let mut file = OpenOptions::new(  ).write( true ).create( true ).open( file_name ).unwrap();
        // Serializes the information
        let data = serde_json::to_string( &self )?;
        // Write the JSON to the filepath
        #[allow(unused_variables)]
        let temp = file.write_all( data.as_ref() );
        // Return result 
        Ok( () )
        
    }
    
}

/*
 *
 * Miner:
 *    - Contains the functionality and associated structs and impls for miners  
 *
 */

// Miner struct
//
// Derive statement used for JSON serialization
#[derive( Serialize, Deserialize )]
pub struct Miner
{

    // The unique ID of the miner, which will be the same as in passport
    uid: String,
    // The cargo that the miner will ship, which is a Merkle Tree of Transactions 
    transactions: Merkle,
    // The block containing the transactions
    package: Block
    
}

// Miner impl
impl Miner
{

    // New constructor
    #[allow(dead_code)]
    pub fn new() -> Self
    {

        // The current ip address
        let ip = Command::new( "ipconfig" ).args( &[ "getifaddr", "en0" ] ).output()
            .expect( "Could not find IP address" );
        // The Command as a string
        let mut ip_string = String::from_utf8( ip.stdout ).unwrap();
        // The string is returned with a new line character so we remove this
        let length = ip_string.len();
        // Truncate by the length - 2 ( "\n" )
        ip_string.truncate( length - 2 );
        // Adds the :3000 string to the ip representing the url
        ip_string.push_str( ":3000" );
        // The hashed url, representing the unique id
        let unique_hash = hash_util::create_leaf_hash( &ip_string.clone() );
        // The current time 
        let current_time = Utc::now().to_string();
        // An empty merkle tree
        let merkle = Merkle::empty();
        // Creates a new block
        let mut block = Block::new( 0, hash_util::empty_hash() );
        // Sets the timestamp
        block.timestamp = current_time;
        // Create and return the miner
        let miner = Miner
        {

            // Sets the fields of the miner to the values calculated above
            uid: unique_hash,
            transactions: merkle,
            package: block
            
        };
        miner
        
    }

    // Serializes the miner as JSON
    #[allow(dead_code)]
    pub fn write_to( &self, file_name: &str ) -> Result< (), Error >
    {
        
        // Open the filepath with write specification
        #[allow(unused_must_use)]
        let mut file = OpenOptions::new(  ).write( true ).create( true ).open( file_name ).unwrap();
        // Serializes the information
        let data = serde_json::to_string( &self )?;
        // Write the JSON to the filepath
        #[allow(unused_variables)]
        let temp = file.write_all( data.as_ref() );
        // Return result
        Ok( () )
            
    }

    // Creates the Merkle Tree given the transaction log
    #[allow(dead_code)]
    pub fn construct_merkle( &mut self, file_name: &str )
    {

        // Gets the node from the transaction log 
        let mut nodes: Vec<Transaction> = Merkle::read_and_construct( file_name).unwrap();
        // Verifies the transactions
        for node in &mut nodes
        {

            node.verify();
            
        }
        // Inserts the nodes into the transaction tree
        for i in 0 .. nodes.len()
        {

            let transaction = &*nodes.get( i ).unwrap();
            self.transactions.insert( transaction.clone() );

        }
        // Resets the values of the block after Merkle Construction 
        self.reset_block_merkle();

    } 

    // Resets the block's Merkle after the nodes are added 
    #[allow(dead_code)]
    pub fn reset_block_merkle( &mut self )
    {

        let root = &*self.transactions.root_hash();
        self.package.merkle_root = root.clone();

    } 
    
} 

/*
 *
 * Trivia:
 *     - The structs and methods associated with a trivia question 
 *
 */

// Question stuct
#[derive( Serialize, Deserialize, Clone )]
#[derive(Debug)]
pub struct Question
{

    // The category of the question
    category: String,
    // The kind ( type ) of question
    #[serde(rename="type")]
    kind: String, 
    // The difficulty of the question
    difficulty: String,
    // The question
    question: String,
    // The correct answer
    #[serde(rename="correct_answer")]
    correct: String,
    // The incorrect answers
    #[serde(rename="incorrect_answers")]
    incorrect: Vec<String>
    
}

// Question impl, has methods for deserializing questions
impl Question
{

    // Returns the question's category
    pub fn category( &self ) -> String
    {

        self.category.clone()
        
    }

    // Returns the question's type
    pub fn kind( &self ) -> String
    {

        self.kind.clone()
        
    }

    // Returns the question's difficulty
    pub fn difficulty( &self ) -> String
    {

        self.difficulty.clone()
        
    }

    // Returns the question
    pub fn question( &self ) -> String
    {

        self.question.clone()
        
    }

    // Returns the correct answer
    pub fn correct( &self ) -> String
    {
        
        self.correct.clone()
        
    }

    // Returns the incorrect answers
    pub fn incorrect( &self ) -> Vec<String>
    {

        self.incorrect.clone()
        
    }
    
    // Constructs the question from JSON
    #[allow(dead_code)]
    pub fn read_and_construct( file_name: &str ) -> Result< Question, Error >
    {

        // Construct the question 
        let string = Question::read_json( file_name );
        let question: Question = serde_json::from_str( string.as_ref().unwrap() ).expect( "Failed to convert JSON to Question" );
        // Return the question
        Ok( question )
        
    }

    // Reads the JSON
    #[allow(dead_code)]
    pub fn read_json( file_name: &str ) -> Result< String, Error >
    {

        // Open a readable file at the filepath
        let mut file = OpenOptions::new( ).read( true ).open( file_name ).unwrap();
        // Reads in JSON
        let mut json = String::new();
        #[allow(unused_variables)]
        let temp = file.read_to_string( &mut json );
        // Return the string
        Ok( json )
        
    }   
    
}

// Archive of all trivia questions
//
// Archives have a vector of questions
#[derive( Serialize, Deserialize, Clone )]
pub struct Archive
{

    // The questions
    log: Vec<Question>
    
}

// Archive impl
impl Archive
{

    // New archive given vector
    pub fn new( vector: Vec<Question> ) -> Self
    {

        Archive
        {

            log: vector
            
        }
        
    }

    // Reads the JSON
    pub fn read_json( file_name: &str ) -> Result< String, Error >
    {

        // Open a readable file at the filepath
        let mut file = OpenOptions::new( ).read( true ).open( file_name ).unwrap();
        // Reads in JSON
        let mut json = String::new();
        #[allow(unused_variables)]
        let temp = file.read_to_string( &mut json );
        // Return the string
        Ok( json )
        
    }   

    // Constructs the log from JSON
    pub fn read_and_construct( file_name: &str ) -> Result< Archive, Error >
    {

        // Construct the question 
        let string = Archive::read_json( file_name ).unwrap();
        // Read the JSON
        let val: Value = serde_json::from_str( string.as_ref() ).expect( "Failed to convert JSON to Archive" );
        // Read the results into a vector
        let log: Vec<Question> = serde_json::from_str( val[ "results" ].to_string().as_ref() ).unwrap();
        // Create an archive out of the vector 
        let archive = Archive::new( log );
        // Return the log
        Ok( archive )
        
    }

    // Returns a random question from the archive
    pub fn random( &self ) -> Question
    {

        // The length of the vector 
        let cap = self.log.capacity();
        // Generates the random number 
        let between = Range::new( 0, cap );
        let mut rng = rand::thread_rng();
        let index = between.ind_sample( &mut rng );
        // The question to return
        let question = self.log.get( index ).clone();
        // Returns the question
        question.unwrap().clone()
        
    }
    
}
